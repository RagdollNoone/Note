网络是怎样连接的
==============

# 第一章

```txt
概要

URL转成HTTP请求
向DNS查询Web服务器IP
DNS递归查找IP
委托操作系统发消息
```

## URL转成HTTP请求

* 什么是URL

```txt
URL： Uniform Resource Locator
统一资源定位符
```

* 有那些不同类的URL

```txt
HTTP例子

http://user:password@www.glasscom.com:80/dir/file1.htm
user    表示用户名(可省略)
password    表示密码(可省略)
www.glasscom.com    表示Web服务器域名
80  表示端口号(可省略)
/dir/file1.htm  表示文件的路径名
```


```txt
FTP例子

ftp://user:password@ftp.glasscom.com:21/dir/file1.htm
user    表示用户名
password    表示密码
ftp.glasscom.com    表示ftp服务器域名
21  表示端口号
/dir/file1.htm  表示文件的路径名
```

```txt
读取本地文件的例子

file://localhost/c:/path/file1.zip
localhost   表示计算机名(可省略)
c:/path/file1.zip   表示文件名
```

```txt
发送电子邮件的例子

mailto:tone@glasscom.com
tone@glasscom.com   表示邮件地址
```

```txt
新闻组的例子

news:comp.protocols.tcp-ip
comp.protocols.tcp-ip   新闻组名
```

* 怎么解析URL

```txt
根据不同URL的例子, 可以知道标准的URL该被怎样解析
但是实际情况是会有很多的省略, 所以主要讨论有省略时
怎么解析URL
```

```txt
1.省略文件名
http://www.lab.glasscom.com/dir/
访问指定目录下的index.html或者default.htm

2.省略目录名和文件名
http://www.lab.glasscom.com
访问根目录下的index.html或者default.htm

3.有二义性的URL
http://www.lab.glasscom.com/whatisthis
有whatisthis的目录时, 当目录解析
有whatisthis的文件时, 当文件解析
不存在一个目录下有同名的文件和文件夹的情况
```

* HTTP请求

```txt
请求包含两个部分
1. 对什么
2. 进行怎样的操作

对什么指的就是URI(统一资源标识符)
URI可以是html文件也可以是cgi文件php文件甚至可以是http:开头的URL

进行怎样的操作有
get 获取文件内容或者返回cgi程序的输出
post    从客户端发送数据
head    只返回消息头
option
put 替换URI上的文件, 如果文件不存在则创建该文件
delete  删除指定文件
trace
connect

最主要的方法就是get和post
```

* 怎么生成HTTP请求消息

```txt
1. 设定方法 在html源码中会指定方法名称get或set
2. 填写URI 从URL当中提取路径
3. 填写消息头
4. 填写消息体 数据在这里填充
```

## 向DNS查询Web服务器IP

* 向DNS服务器查询步骤

```txt
1. 调用DNS服务器的客户端部分(也叫解析器, 是一段socket程序)
如果上层的程序是一段C代码, 那么这个过程就是调用gethostbyname函数
2. 解析器委托给操作系统的协议栈来发送消息, 消息通过网卡发送到远端
3. Windows自动获得DNS服务器是什么概念, DNS服务器会由网络运营商主动提供的,
这一般会写在和家庭端口直连的第一级路由器上
```

* DNS消息信息组成

```txt
域名
class(多余字段)
记录类型(mx表示邮件, A表示IP)
ip地址(值得注意的是邮件地址还配有优先级 数值越是小 更优先)
```

* 具体根据域名查询IP的过程

```txt
假设查询www.lab.glasscom.com这个域名的IP

1. 先查询本机配置的指定的DNS服务器
2. 如果上述DNS服务器没有指定域名的信息, 转发域名到根DNS服务器, 委托它代为查询
3. 如果根服务器也没有相应的信息, 再逐级递归查询, 先查com, 之后glasscom...

实际的情况是com和glasscom可能共享一台实体的DNS服务器, 所以查询次数不会那么多
并且com所在的DNS服务器可能会被缓存
不存在的域名也会被缓存

另一个需要注意的是缓存的信息有可能过时, 所以超过有效期后应该被删除
```

## 委托协议栈发送数据

* 收发数据的过程

```txt
服务器创建socket
客户端连接
通过管道收发数据
断开管道删除socket
```

* 连接的过程

```txt
调用connect函数

需要知道
socket的文件描述符
ip
端口

注意本地的应用程序和socket通信时运用的是文件描述符
而两端的socket通信时需要用端口
设计是可以理解的 本地的文件描述符应该是私有的

服务端的端口号根据程序功能 采用默认约定的端口号码
客户端的端口号是随机分配连接时告诉服务端
所以接下来的读写操作只要传客户端的端口信息即可

可以认为端口号和文件描述符是做着同样的事情 只是面向的对象不同
```

# 第二章

```txt
概要

创建socket
连接服务器
收发数据
断开并删除socket
IP与以太网包收发操作
UDP收发数据操作
```

![Overview](./Picture/Chapter2/Overview.png)

## 层次间的分工及名词解释

``` txt
0. socket可以认为是描述通信连接的状态的内存空间
1. socket中的解析器: 负责查询DNS(gethostbyname)
2. 协议栈: 就是TCP/UDP IP的总称 属于操作系统层 ICMP和ARP又是IP的子集
3. 一般应用程序发送数据采用TCP DNS查询等收发较短数据时采用UDP
4. ICMP用于告知传送过程中产生的错误及各种控制消息
5. ARP用于根据IP地址查找MAC地址
```

## socket信息

![socket infomation](./Picture/Chapter2/SocketInformation.png)

## 关于所谓的控制信息

```txt
控制信息分为两类
1. 数据包头部中记录的信息(TCP头部 IP头部 以太网头部)
2. 协议栈内存空间中记录的信息

头部的信息是共通的 所以Windows和Linux能够通信
协议栈内存空间中的信息是不同的 因为Window和Linux有不同的实现
```

## 创建socket

```txt
开辟出一块内存空间存放通信的信息和状态 返回一个文件描述符(int)
```

## connect

```txt
一个连接可以被称为connection或是session

连接的实质是交换通信两端的控制信息 并把这些信息存储到socket当中
以及做好收发数据的准备这一系列的操作

在客户端这边需要把应用程序知道的目标IP告诉给底层的协议栈
服务器这边需要客户端告知自身的IP和端口信息

注意执行读写操作时 需要分配一块内存空间作为缓冲区 这也是连接的时候分配的
(这个缓冲区的大小 是否会益出)

调用socket库的connect 会执行一下的几步逻辑
1. 创建TCP头部的控制信息结构
这一步主要关注的是
收发双方的端口号
设置滑动窗口大小
设置起始序列号(是一个随机的值 不然发送出去的序号总是从0开始 容易被冒名顶替)
客户端把TCP头部的SYN字段设为1
2. 当TCP头部创建好之后 TCP模块会委托IP模块发送数据包 之后服务器就会收到数据包
3. 当服务器的TCP模块收到数据包之后 会根据端口号找对应的socket
4. 如果找到了对应的socket 那么则写入相关的信息 并把连接状态设置为正在连接
5. 然后反向发送响应消息 发送响应消息时 TCP头部的SYN和ACK字段设为1
这样做的目的是 连接传输的过程中 是有可能丢包的
所以需要有对应的字段来通知两端数据接受的情况
6. 消息返回客户端后 检查SYN字段是否为1 是的话表示连接成功 在客户端写入服务器的IP地址
7. 最后客户端发送响应消息给服务器 连接完成

上述步骤完成之后 客户端服务器两端可以随时收发信息 控制流从connect函数 返回应用程序
```

![TCP Header](./Picture/Chapter2/TCPHeader.png)

## 收发数据

```txt
1. 首先协议栈不会关心收发的数据具体是什么内容
在协议栈看来 这只是一定长度的二进制字节序而已

2. 其次数据包也不会马上发送出去 因为应用程序发过来的可能是小包
直接发送会降低网络的使用率 所以协议栈会等到数据量达到一个值的
情况下发出去 或者 一定时间后发出去

由于栈的设计不一定能满足所有应用程序的需要 所以提供了接口给
应用程序 可以让它来选择发包的策略

那么这个值是多少呢
一般从应用程序收到大于或接近MSS长度的数据 就会发包
MTU: 一个网络包最大的长度 一般是1500个字节
MSS: 除去头部之后 一个网络包所能容纳TCP数据的最大长度

对于较大的数据包 则会采用分割的方式 拆包发送

3. 接下来要考虑的是收包后的确认和丢包的重发
之前连接时提到的起始序号就是在这里派上用处的
所谓的起始序号 就是计算出数据块的字节偏移量加上一个随机的值
这个随机值是在连接时两端握手时同步好的值

至于重发是通过滑动窗口来实现的 连接时会设置滑动窗口的大小
所有发送过却没有收到ACK的包都会缓存在滑动窗口当中 如果没有
收到ACK就会适时重发 但是如果网络断开连接 无论怎么重发 都不会
有结果 这时TCP会断开连接 并向应用程序报错

既然提到了滑动窗口 那么不等待ACK的发送方式是有可能导致这个
窗口的溢出的 但这个问题是在TCP层解决的 窗口剩余的容量是通信
两端会同步的一个值 接收方如果缓冲区满了 那么会告知发送方这个
信息 那么发送方不会继续发送消息 直到缓冲区有空闲的空间

4. 最后讨论发送ACK包和更新窗口大小的包的时机
首先先讨论标准的情况
ACK包应该一收到发送方的数据包 就发送
更新窗口的包应该是应用程序从缓冲区当中拿走包之后发送

但是如果严格按照上述规则执行的话 包的数量就太多了
所以真实的情况是 这两种包都会延时合并发送 并且当有
多个连续的ACK包要发送时 只发送最后一个序号 表示之
前的包都已经收到
```
![MTU and MSS](./Picture/Chapter2/MTUMSS.png)

## 断开并删除连接

```txt
断开的过程:
协议栈在设计上允许任何一端发起断开 具体的函数就是close
发送FIN字段为1的TCP包 给对方 收到对方确认包后 做实断开
如果在断开后 应用程序试图读取数据 那么并不会返回数据
而是得到对方的数据已经全部发送完了的通知

删除过程:
会等待几分钟(包的重传过程结束)后 删除socket
理由如下
一端释放socket后 发给另一端的ACK包发生了丢包
那么一段时间后另一端会重发FIN=1的包 此时释放
的socket的文件描述符可能已经被分配给新的连接
收到重发的包之后 会释放新的连接 从而引发bug
```
![TCP Process](./Picture/Chapter2/TCPProcess.png)

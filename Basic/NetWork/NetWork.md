网络是怎样连接的
==============

# 第一章

```txt
概要

URL转成HTTP请求
向DNS查询Web服务器IP
DNS递归查找IP
委托操作系统发消息
```

## URL转成HTTP请求

* 什么是URL

```txt
URL： Uniform Resource Locator
统一资源定位符
```

* 有那些不同类的URL

```txt
HTTP例子

http://user:password@www.glasscom.com:80/dir/file1.htm
user    表示用户名(可省略)
password    表示密码(可省略)
www.glasscom.com    表示Web服务器域名
80  表示端口号(可省略)
/dir/file1.htm  表示文件的路径名
```


```txt
FTP例子

ftp://user:password@ftp.glasscom.com:21/dir/file1.htm
user    表示用户名
password    表示密码
ftp.glasscom.com    表示ftp服务器域名
21  表示端口号
/dir/file1.htm  表示文件的路径名
```

```txt
读取本地文件的例子

file://localhost/c:/path/file1.zip
localhost   表示计算机名(可省略)
c:/path/file1.zip   表示文件名
```

```txt
发送电子邮件的例子

mailto:tone@glasscom.com
tone@glasscom.com   表示邮件地址
```

```txt
新闻组的例子

news:comp.protocols.tcp-ip
comp.protocols.tcp-ip   新闻组名
```

* 怎么解析URL

```txt
根据不同URL的例子, 可以知道标准的URL该被怎样解析
但是实际情况是会有很多的省略, 所以主要讨论有省略时
怎么解析URL
```

```txt
1.省略文件名
http://www.lab.glasscom.com/dir/
访问指定目录下的index.html或者default.htm

2.省略目录名和文件名
http://www.lab.glasscom.com
访问根目录下的index.html或者default.htm

3.有二义性的URL
http://www.lab.glasscom.com/whatisthis
有whatisthis的目录时, 当目录解析
有whatisthis的文件时, 当文件解析
不存在一个目录下有同名的文件和文件夹的情况
```

* HTTP请求

```txt
请求包含两个部分
1. 对什么
2. 进行怎样的操作

对什么指的就是URI(统一资源标识符)
URI可以是html文件也可以是cgi文件php文件甚至可以是http:开头的URL

进行怎样的操作有
get 获取文件内容或者返回cgi程序的输出
post    从客户端发送数据
head    只返回消息头
option
put 替换URI上的文件, 如果文件不存在则创建该文件
delete  删除指定文件
trace
connect

最主要的方法就是get和post
```

* 怎么生成HTTP请求消息

```txt
1. 设定方法 在html源码中会指定方法名称get或set
2. 填写URI 从URL当中提取路径
3. 填写消息头
4. 填写消息体 数据在这里填充
```

## 向DNS查询Web服务器IP

* 向DNS服务器查询步骤

```txt
1. 调用DNS服务器的客户端部分(也叫解析器, 是一段socket程序)
如果上层的程序是一段C代码, 那么这个过程就是调用gethostbyname函数
2. 解析器委托给操作系统的协议栈来发送消息, 消息通过网卡发送到远端
3. Windows自动获得DNS服务器是什么概念, DNS服务器会由网络运营商主动提供的,
这一般会写在和家庭端口直连的第一级路由器上
```

* DNS消息信息组成

```txt
域名
class(多余字段)
记录类型(mx表示邮件, A表示IP)
ip地址(值得注意的是邮件地址还配有优先级 数值越是小 更优先)
```

* 具体根据域名查询IP的过程

```txt
假设查询www.lab.glasscom.com这个域名的IP

1. 先查询本机配置的指定的DNS服务器
2. 如果上述DNS服务器没有指定域名的信息, 转发域名到根DNS服务器, 委托它代为查询
3. 如果根服务器也没有相应的信息, 再逐级递归查询, 先查com, 之后glasscom...

实际的情况是com和glasscom可能共享一台实体的DNS服务器, 所以查询次数不会那么多
并且com所在的DNS服务器可能会被缓存
不存在的域名也会被缓存

另一个需要注意的是缓存的信息有可能过时, 所以超过有效期后应该被删除
```

## 委托协议栈发送数据

* 收发数据的过程

```txt
服务器创建socket
客户端连接
通过管道收发数据
断开管道删除socket
```

* 连接的过程

```txt
调用connect函数

需要知道
socket的文件描述符
ip
端口

注意本地的应用程序和socket通信时运用的是文件描述符
而两端的socket通信时需要用端口
设计是可以理解的 本地的文件描述符应该是私有的

服务端的端口号根据程序功能 采用默认约定的端口号码
客户端的端口号是随机分配连接时告诉服务端
所以接下来的读写操作只要传客户端的端口信息即可

可以认为端口号和文件描述符是做着同样的事情 只是面向的对象不同
```

# 第二章

```txt
概要

创建socket
连接服务器
收发数据
断开并删除socket
IP与以太网包收发操作
UDP收发数据操作
```

![Overview](./Picture/Chapter2/Overview.png)

## 层次间的分工及名词解释

``` txt
0. socket可以认为是描述通信连接的状态的内存空间
1. socket中的解析器: 负责查询DNS(gethostbyname)
2. 协议栈: 就是TCP/UDP IP的总称 属于操作系统层 ICMP和ARP又是IP的子集
3. 一般应用程序发送数据采用TCP DNS查询等收发较短数据时采用UDP
4. ICMP用于告知传送过程中产生的错误及各种控制消息
5. ARP用于根据IP地址查找MAC地址
```

## socket信息

![socket infomation](./Picture/Chapter2/SocketInformation.png)

## 关于所谓的控制信息

```txt
控制信息分为两类
1. 数据包头部中记录的信息(TCP头部 IP头部 以太网头部)
2. 协议栈内存空间中记录的信息

头部的信息是共通的 所以Windows和Linux能够通信
协议栈内存空间中的信息是不同的 因为Window和Linux有不同的实现
```

## 创建socket

```txt
开辟出一块内存空间存放通信的信息和状态 返回一个文件描述符(int)
```

## connect

```txt
一个连接可以被称为connection或是session

连接的实质是交换通信两端的控制信息 并把这些信息存储到socket当中
以及做好收发数据的准备这一系列的操作

在客户端这边需要把应用程序知道的目标IP告诉给底层的协议栈
服务器这边需要客户端告知自身的IP和端口信息

注意执行读写操作时 需要分配一块内存空间作为缓冲区 这也是连接的时候分配的
(这个缓冲区的大小 是否会益出)

调用socket库的connect 会执行一下的几步逻辑
1. 创建TCP头部的控制信息结构
这一步主要关注的是
收发双方的端口号
设置滑动窗口大小
设置起始序列号(是一个随机的值 不然发送出去的序号总是从0开始 容易被冒名顶替)
客户端把TCP头部的SYN字段设为1
2. 当TCP头部创建好之后 TCP模块会委托IP模块发送数据包 之后服务器就会收到数据包
3. 当服务器的TCP模块收到数据包之后 会根据端口号找对应的socket
4. 如果找到了对应的socket 那么则写入相关的信息 并把连接状态设置为正在连接
5. 然后反向发送响应消息 发送响应消息时 TCP头部的SYN和ACK字段设为1
这样做的目的是 连接传输的过程中 是有可能丢包的
所以需要有对应的字段来通知两端数据接受的情况
6. 消息返回客户端后 检查SYN字段是否为1 是的话表示连接成功 在客户端写入服务器的IP地址
7. 最后客户端发送响应消息给服务器 连接完成

上述步骤完成之后 客户端服务器两端可以随时收发信息 控制流从connect函数 返回应用程序
```

![TCP Header](./Picture/Chapter2/TCPHeader.png)

## 收发数据

```txt
1. 首先协议栈不会关心收发的数据具体是什么内容
在协议栈看来 这只是一定长度的二进制字节序而已

2. 其次数据包也不会马上发送出去 因为应用程序发过来的可能是小包
直接发送会降低网络的使用率 所以协议栈会等到数据量达到一个值的
情况下发出去 或者 一定时间后发出去

由于栈的设计不一定能满足所有应用程序的需要 所以提供了接口给
应用程序 可以让它来选择发包的策略

那么这个值是多少呢
一般从应用程序收到大于或接近MSS长度的数据 就会发包
MTU: 一个网络包最大的长度 一般是1500个字节
MSS: 除去头部之后 一个网络包所能容纳TCP数据的最大长度

对于较大的数据包 则会采用分割的方式 拆包发送

3. 接下来要考虑的是收包后的确认和丢包的重发
之前连接时提到的起始序号就是在这里派上用处的
所谓的起始序号 就是计算出数据块的字节偏移量加上一个随机的值
这个随机值是在连接时两端握手时同步好的值

至于重发是通过滑动窗口来实现的 连接时会设置滑动窗口的大小
所有发送过却没有收到ACK的包都会缓存在滑动窗口当中 如果没有
收到ACK就会适时重发 但是如果网络断开连接 无论怎么重发 都不会
有结果 这时TCP会断开连接 并向应用程序报错

既然提到了滑动窗口 那么不等待ACK的发送方式是有可能导致这个
窗口的溢出的 但这个问题是在TCP层解决的 窗口剩余的容量是通信
两端会同步的一个值 接收方如果缓冲区满了 那么会告知发送方这个
信息 那么发送方不会继续发送消息 直到缓冲区有空闲的空间

4. 最后讨论发送ACK包和更新窗口大小的包的时机
首先先讨论标准的情况
ACK包应该一收到发送方的数据包 就发送
更新窗口的包应该是应用程序从缓冲区当中拿走包之后发送

但是如果严格按照上述规则执行的话 包的数量就太多了
所以真实的情况是 这两种包都会延时合并发送 并且当有
多个连续的ACK包要发送时 只发送最后一个序号 表示之
前的包都已经收到
```
![MTU and MSS](./Picture/Chapter2/MTUMSS.png)

## 断开并删除连接

```txt
断开的过程:
协议栈在设计上允许任何一端发起断开 具体的函数就是close
发送FIN字段为1的TCP包 给对方 收到对方确认包后 做实断开
如果在断开后 应用程序试图读取数据 那么并不会返回数据
而是得到对方的数据已经全部发送完了的通知

删除过程:
会等待几分钟(包的重传过程结束)后 删除socket
理由如下
一端释放socket后 发给另一端的ACK包发生了丢包
那么一段时间后另一端会重发FIN=1的包 此时释放
的socket的文件描述符可能已经被分配给新的连接
收到重发的包之后 会释放新的连接 从而引发bug
```
![TCP Process](./Picture/Chapter2/TCPProcess.png)

## IP及以太网发包

![Package Header](./Picture/Chapter2/PackageHeader.png)

```txt
路由器  根据目标地址确定下一个路由的IP地址  IP头部       IP协议
集线器  在子网中把包传递给下一个路由               MAC头部  以太网协议

以太网的部分可以替换成别的(无线局域网 ADSL FTTH)

IP传递过程
一个包的头部信息中只有目的地的IP信息 不存在下一跳路由的IP信息
当从路由表中查到下一跳路由的地址信息后 直接ARP成MAC地址 之后
写入到MAC头部中发送出去

ARP
ARP是广播查询当前子网内IP的MAC地址 为了防止网络内充斥着ARP的
包 所以设计了ARP的缓存 只有在缓存中找不到对应的IP地址 才会广播
查询 但是当子网中有加入/退出计算机时 ARP缓存就会过时 导致发包
异常 解决的方案是 过几分钟后 缓存全部清除

集线器的演变
网卡负责把数字信号转换成电信号 物理层的网络是共享总线的形态
这就导致 同时发送时对总线使用的冲突 为了解决这个问题 最初设计
了载波监听的协议 然后集线器也因此发生了演变 如中继式集线器
交换式集线器 当前使用的都是交换式集线器 它的优点是 不再通过总
线上的每个节点 而是点对点的发送数据 同时发送数据时 信号也不在
碰撞

网卡的MAC地址
网卡不是通电即可用的 是需要操作系统对它进行初始化的(网卡驱动程序)
这个初始化的过程会改变最终的MAC地址 虽然生产的时候写入了唯一的
MAC地址 但是也可以在初始化的时候可以指定MAC地址是配置信息当中
说明的地址

实际物理层的传输细节
光有高低电压是不够的 因为连续的1或0信号无法确定到底有几个1或是0
所以还要有时钟信息 这个概念等同与传输速率 即电脑将数字信号转换成
电信号的速度 实际传输时 通信的两端需要先同步这个速度 才能开始发送
除了这点以外 还约定了起始帧说明同步结束 后面的信号为数据信号 以及
最后的校验

两台设备间的距离一般不超过100米
```

![Route Table](./Picture/Chapter2/RouteTable.png)

![ARP](./Picture/Chapter2/ARP.png)

## UDP

```txt
1.使用时机 包很小 重传的代价因此变的很小
应用程序会给出响应包 可认为是TCP对应的
ACK包

2.音频视频类型文件的传输 这个文件丢包后重传
没有意义 所以需要选择UDP
```

# 第三章

```txt
概要

信号在网线和集线器当中的传输
交换机转发包操作
路由器转发包操作
路由器附加功能
```
![Struct](./Picture/Chapter3/Struct.png)

## 信号在网线和集线器当中的传输

```txt
电信号在传输的时候能量会有损失 传输的距离越远 损失越大
出现错误的概率就越大

网线为什么是双绞线
为了抑制感应电流对传输的影响 这里分两种情况
一种是外部变化的磁场 产生的感应电流
另一种是内部临近的信号线 产生的感应电流

直连网线和交叉网线
通信的两端 信号线的一端是发送 那么同根信号线的另一端对应的是接收
这样的网线被称为交叉线 不过现在已经不再使用了 应为网卡可以自动适配
可以理解网卡不能适配的情况下 电脑和电脑 路由和路由之间选择交叉线
不能理解的是电脑和路由间为什么选择直连？
```

![Cross Talk](./Picture/Chapter3/CrossTalk.png)

## 交换机转发包操作

```txt
集线器
1.传播方式是广播 会把数据包广播给同一子网中的所有设备
2.没有表
3.集线器端口没有MAC地址
4.不支持同时发送接收数据 同时发送数据会发生碰撞

交换机
1.传播方式是点对点
2.有目标地址和端口关系的表
3. 交换机端口没有MAC地址
4. 能同时发送数据(全双供模式)

交换机和集线器只是负责转发 只不过转发的方式不同 一个是点对点
一个是广播 转发的依据是目标的MAC地址

交换机的路由表操作
添加  新设备通过网线连上交换机 并发包 交换机会记录发送方的MAC及对应端口
删除 设备从交换机上面移除 依赖交换机一段事件后的自动删除 或者手动重启更新

交换机路由的丢包和重包
1. 目标移动设备从当前交换机退出时 有可能会发生丢包 重启即可
2. 发送设备先连接集线器 在连接交换机 而接收设备在同一集线器
的子网内 会发生重包 这种情况下 由交换机处理 处理的方式是直接
丢弃该包
```

![Repeated Package](./Picture/Chapter3/RepeatedPackage.png)

## 路由器转发包操作

![Route Send Package](./Picture/Chapter3/RouteSendPackage.png)

```txt
路由器端口模块除了以太网和无线局域网之外还支持很多别的技术
如ADSL, FTTH, 以及一些带宽专线

路由器的端口是有MAC地址的 这意味着路由器可以是以太网的发送方和接收方
而且路由器端口也有IP地址 这意味着在网络中本质上它和一台计算机的网卡并
没有区别

路由器是根据IP来判断的转发目标的

路由表会聚合和拆分 某一台主机的IP也会单独写到路由表当中去

路由表的维护是通过
1.人工维护
2.通过路由协议(RIP, OSPC, BGP)机制 由路由器之间交换信息 自动更新

路由器遇到不明地址的包会直接丢弃 而交换机可能会做一次广播

TTL(Time To Live)
指的是包的生存周期 每经过一个路由器 这个值就会减1 如果这个值等于0的
时候 这个包就会被丢弃 这样做是为了 即使网络路由配置错误 出现了闭环
包的传输也不会进入死循环

由于ADSL， FTTH和以太网的MTU(最大包的长度)可能不同 所以要在路由器这
一层做一下分包操作 以便把包进行转发

路由器目标地址确定方法
目标地址 = 网关地址 != NULL ? 网关地址 : IP头部的目标地址
之后就是借助ARP协议 广播根据IP查询对应的MAC地址
```

## 路由器的附加功能

```txt
1.地址转换
2.过滤包

地址转换是为了解决公网IP地址紧张的问题
一家公司可能有上千台计算机 极端的情况下 只需要一台路由器
配置公网IP地址 就可以让这些计算机访问互联网

地址转换指的是内网访问外网 需要在路由器当中添加一条路由信息 记录路由端口和
内网IP以及端口的对应关系(改写了IP地址和端口号)

如果想要从公网 访问内网的一台计算机 则需要手动(被认证)的在路由器当中添加一条记录
指明访问路由的那个端口 其实就是对应的内网的某个IP和端口

过滤包指的就是计算机的防火墙
```

![Visit Internet](./Picture/Chapter3/VisitInternet.png)

# 第四章

```txt
概述
ADSL接入网的结构和工作方式
FTTH接入网的结构和工作方式
接入网中的PPP和隧道
网络运营商的内部
跨越运营商的网络包
```

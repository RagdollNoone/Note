ravindrababu ravula Computer Network
====================================

# lesson13

* sliding window protocol

```txt
这种协议有两种实现方式
1.GBN Go Back N
2.SR Selective Repeat
```

* GBN

```txt
N代表回退的packets的数量
一般情况下N总是大于1的, 如果N等于1, 退化成Stop And Wait协议

1. sender window
发送窗口的大小是N, 这没什么说的..., GBN嘛, 发送窗口如果不是N, 就和定义矛盾了

2. receiver window
接收窗口的大小默认是1, 这是有设计上的思考的
假设发送窗口的大小是4, 接收窗口的大小是1, 现在正在发送窗口的包的序列号是0, 1, 2, 3
下一刻0号包的Time Out time到了, 发送端认为0号包丢失, 那么选择GBN协议, 重发的策略是
0, 1, 2, 3全部重发, 而不是等到1号包的Time Out time到了才重发1号包, 这是由于
接收窗口只接收特定序号的包, 所以如果0号包没有被接收, 那么1, 2, 3可以认为都丢了

3. acknowledgment
确认包的发送机制有两种,
一种是cummulate Ack
一种是independent Ack

说明下这两种发送的优缺点
cummulate Ack
优点: 发送的数据量少
缺点: 关联性差 如果一次ack发生了丢包, 那么上一次确认包到这一次确认包之间所有的数据包都会被认为丢失

independent Ack
优点: 关联性强, 那个数据包丢失是知道的, 重发指定数据包即可
缺点: 发送的数据量大, 显然每个数据包都需要回包

GBN用的是cummulate Ack
```

* 关于回包的策略

```txt
很多情况下, 发送端的数据长度不一定是滑动窗口的整数倍, 所以不能采用接收N个包就发送一个Ack包的策略
甚至有时候, 不管N为几发送端就是需要单独发送一个包, 这种情况也是存在的
所以接收端的回包策略是当收到一个数据包时, 起一个定时器, 当时间片到的时候, 返回累积序列号,
比如说在一个时间片内收到了序列号为0, 1的数据包, 返回的累积序列号就是2
(但是这种策略怎么解决0号丢失, 1号数据包正常接收的情况呢? 其实这种情况是不存在的, 应为接收window的大小
是1, 所以收不到0号包, 1号包也是收不到的)

那么时间片的大小该怎么选择呢?
需要注意的是
时间片过大 会导致发送端认为 数据包丢失
如果时间片过小 回包模式退化成 independent Ack 失去发送数据量小的优势
```

* Relationship between window size and sequence number

```txt
结论: Ws(发送窗口的大小) + Wr(接收窗口的大小) <= ASN(数据序列号的最大值)
```
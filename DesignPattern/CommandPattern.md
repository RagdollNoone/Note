命令模式
=======

## 定义

```txt
将请求封装成对象, 以便使用不同的请求, 队列或者
日志来参数化其他对象. 命令模式也可执行撤销操作
```
## Why

```txt
记录工作日志
重复使用命令实现撤销

动作的请求者从动作的执行者对象中解耦
把执行者和具体的请求封装成一个对象
请求者不需要知道工作具体内容是什么,
只要调用正确的命令就好了(执行命令的
execute方法)
```

## How

```txt
命令的子类名称能够反应具体要执行什么操作
执行者是谁, 并且和执行者对象组合, 命令的
基类只需要声明execute和undo函数即可

undo时命令队列的访问应该和execute的反向

可以构造一个什么都不执行的command应对无效
的操作, 这样代码里面可以少很多null == command
的判断语句

可以设计一个执行过的命令队列来undo一系列的命令
undo不应该被加到命令队列当中去
```

## When

* 工作队列

```txt
工作队列的两端分别是待添加的命令和线程, 线程总是从队列当中取出一个命令执行,
等待命令执行完成后, 再取出下一个命令, 继续执行
```

* 日志请求

```txt
可以将命令序列化到磁盘, 然后当出现意外情况时(死机?), 从磁盘上读取命令, 然后
还原之前的状态(举个例子来说的话, 像Excel编辑时, 突然死机了, 重启后的还原功能)
```

## 扩展

* 接收者对象不一定要存在, "聪明"的命令对象能直接完成一个请求, 什么才叫聪明？(P267)
* 很显然这种模式非常吃内存, 怎么设计出一种不怎么吃内存的命令模式
* 持久化(Serialization/persistence)
* 检查点(checkpoint), 不是每次变化就存整体, 而是检查点存整体, 检查点之间靠命令日志
* 事务处理(transaction)

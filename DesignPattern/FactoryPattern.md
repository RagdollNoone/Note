工厂模式
=======

## 静态工厂
优点: 不需要创建工厂对象就能生产所需要的对象
缺点: 不能通过继承来改变创建方法的行为(TODO)

## 工厂方法

### 定义

```txt
定义一个创建对象的接口, 但由子类决定要实例化的类
究竟是哪一个, 工厂方法将实例化的的过程推迟到子类
```

### How

```txt
这个模式需要创建者类和产品类, 两者是平行的, 因
为他们都有一个抽象的基类, 和许多具体的子类实现
对于创建者类的子类, 他拥有创建具体产品的方法,
这个方法被称为工厂方法

工厂方法并不一定要是抽象的, 可以在基类当中实现一个
默认的工厂方法, 这样子类即使没有覆盖创建方法, 也可以
有创建的具体实现
```

## 抽象工厂

### 定义

```txt
提供一个接口, 用于创建相关或依赖对象的家族, 而不需要明确指定具体类
```

### How

附图


## 工厂方法和抽象工厂

```txt
1. 工厂方法
不变的是批萨的制作流程(创建, 准备, 烘培, 切割, 包装), 或者更贴切的说是创建批萨本身
变的是批萨的种类

创建者是批萨店
产品是单个批萨

2. 抽象工厂
不变的是批萨的组成(都是由面团, 酱料, 芝士等组成的), 变的是每个地方的这些原材
料是不同的

创建者是原料工厂
产品是原料们(一次生产需要得到一种面团, 一种酱料, 一种芝士)

抽象工厂的具体实现中还是有工厂方法的影子

抽象工厂在添加/删除原料的操作上显得复杂, 比如说现在批萨由面团, 酱料, 芝士和蔬菜组成了
```

## 设计原则

```txt
 要依赖抽象类, 而不是具体类
 不能让高层组件依赖低层组件, 而且两者都应该依赖抽象对象
```

 ## 倒置原则

```txt
高层组件和低层组件都依赖共同的抽象类

变量不可以持有具体类的引用
不要让类派生自具体类
不要覆盖基类中已经实现的方法
```

## 扩展
* 枚举比字符串作为参数的优势在于, 如果你拼写错误了, 对于枚举类型, 你可以在编译期就发现问题

栈区域又可以理解为线程栈 每一个线程都有自己的一个栈

当某个线程执行一个方法的时候 栈会分配一个更小的单元 栈帧

程序计数器是每个线程专有的 java会有多线程 所以当前线程会被打断 所以需要程序计数器来还原

方法区存放常量 静态变量 类信息(类的方法地址) 如果静态变量是一个new出来的对象 在方法区存放
的是它的地址 实体在堆上面

本地方法 native修饰的函数 叫做本地方法 往往这些方法用c或c++编写 但是这些方法的执行仍需
内存空间 因此存在本地方法区

gc时 找垃圾的算法 早期引用计数法 现在可达性分析算法 如果一个对象的年龄超过15 就会被放置在
老年代的区域

OOM内存溢出

调优工具 Arthas 调优最主要的工作是减少full gc, gc时会stop the world用户感知死机 stw的机制
是必要的因为 gc线程执行时 用户线程可能已经释放了 但是其之前被标明为非垃圾 这样会有矛盾 导致必须
重新做可达性计算 最终有可能使gc无法被完成

垃圾收理器 早期CMS 现在G1

kafka rocket

G1边回收 边释放 不要等Eden区满了再做GC

所谓IOC ，就简短一句话：对象由spring来创建、管理，装配！

IOC和DI是从不同的角度描述的同一件事，IOC是从容器的角度描述，而DI是从应用程序的角度来描述，
也可以这样说，IOC是依赖倒置原则的设计思想，而DI是具体的实现方式

Spring的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和
面向切面编程（aspect-oriented programming，AOP）。

Spring 框架中都用到了哪些设计模式？
工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；
单例模式：Bean默认为单例模式。
代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；
模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。


BeanFactory 和 ApplicationContext有什么区别？
BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。
其中ApplicationContext是BeanFactory的子接口。


解释Spring支持的几种bean的作用域
Spring框架支持以下五种bean的作用域：
singleton : bean在每个Spring ioc 容器中只有一个实例。
prototype：一个bean的定义可以有多个实例。
request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。
session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效
注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。

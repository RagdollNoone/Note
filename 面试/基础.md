## 谈谈你对 Java 平台的理解

 Java 本身是一种面向对象的语言，最显著的特性有两个方面

* 1
```txt
书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力

众所周知，我们通常把 Java 分为编译期和运行时。这里说的 Java 的编译和 C/C++ 是有着
不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，
而不是可以直接执行的机器码。Java 通过字节码和 Java 虚拟机（JVM）这种跨平台的抽象，
屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。
```

* 2
```txt
 另外就是垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，
大部分情况下，程序员不需要自己操心内存的分配和回收。
```

## Exception和Error有什么区别

对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别

```txt
Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才
可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。

Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常
运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。

Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序
（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需
要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。
```

常用处理

```txt
https://blog.csdn.net/qweqwruio/article/details/81329342
1. 尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常

2. 不要生吞（swallow）异常

3. 对于分布式系统，如果发生异常，但是无法找到堆栈轨迹（stacktrace），
所以，使用产品日志，详细地输出到日志系统里。尽量少用
e.printStackTrace();

4. Throw early, catch late 原则
```

```Java
public void readPreferences(String filename) {
    Objects. requireNonNull(filename);
    //...perform other operations...
    InputStream in = new FileInputStream(filename);
    //...read the preferences file...
}
```

代价

```txt
try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行
优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；

与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句
（if/else、switch）要低效。Java 每实例化一个 Exception，都会对当时的栈进行快照，
这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。
```


## 谈谈final、finally、 finalize有什么不同

final
```txt
final 修饰的 class 代表不可以继承扩展
final 的变量是不可以修改的, 修饰的集合对象是不能重新赋值的，而可以向集合中添加元素。
final 的方法也是不可以重写的（override）
```

finally
```txt
则是 Java 保证重点代码一定要被执行的一种机制。
我们可以使用 try-finally 或者 try-catch-finally 来进行
类似关闭 JDBC 连接、保证 unlock 锁等动作。
```

finalize
```txt
是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成
特定资源的回收。

finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。
```

## 强引用、软引用、弱引用、幻象引用有什么区别

不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。

强引用（“Strong” Reference）
```txt
就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，
垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了
引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，
当然具体回收时机还是要看垃圾收集策略。
```

软引用（SoftReference）
```txt
是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存
不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，
清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以
暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
```

弱引用（WeakReference）
```txt
并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用
来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对
象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。
```

## String、StringBuffer、StringBuilder 有什么区别

```txt
String类是 Immutable 的 是final类 所有属性也是final 所以不便拼接

StringBuffer为了解决拼接的问题而存在 而且是线程安全的 但也意味着有更多的开销

StringBuilder和StringBuffer相同 但是不是线程安全的 但是开销也较小 是大部分字符串
操作的首选
```

## 动态代理是基于什么原理

```txt

```

## int和Integer有什么区别

```txt
int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、
byte 、short、char、int、float、double、long）之一。

Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，
比如数学运算、int 和字符串之间转换等。

在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，
不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。
```

## Vector、ArrayList、LinkedList有何区别

```txt
区别在行为、性能、线程安全等方面，表现又有很大不同。

Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，
毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的
增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。

ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。
与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，
Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。

LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，
它也不是线程安全的。
```

## Hashtable、HashMap、TreeMap有什么不同

```txt
Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，
由于同步导致的性能开销，所以已经很少被推荐使用。

HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于
HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，
可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个
用户 ID 和用户信息对应的运行时存储结构。

TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、
put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的
Comparator 来决定，或者根据键的自然顺序来判断。
```

## 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全

```txt

```

## Java提供了哪些IO方式？ NIO如何实现多路复用？

```txt
输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。

Reader/Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写
入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当
于构建了应用逻辑和原始数据之间的桥梁。

BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。
这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。
```

## synchronized 和 ReentrantLock 有什么区别

```txt
1. 理解什么是线程安全

* 原子性 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
* 可见性 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态
反映到主内存上，volatile 就是负责保证可见性的。
* 有序性 是保证线程内串行语义，避免指令重排等。

2. synchronized、ReentrantLock区别
ReentrantLock 相比 synchronized，因为可以像普通对象一样使用，所以可以利用其提供的各种便利
方法，进行精细的同步操作，甚至是实现 synchronized 难以表达的用例，如：

带超时的获取锁尝试。
可以判断是否有线程，或者某个特定线程，在排队等待获取锁。
可以响应中断请求。
```

## synchronized 底层如何实现？什么是锁的升级、降级

```txt
```

## 线程的生命周期和状态转移

1. 线程究竟是什么
```txt
从操作系统的角度，可以简单认为，线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的
真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，
但是会和进程内其他线程共享文件描述符、虚拟地址空间等。
```

2. 线程的状态
```txt
* 新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。

* 就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，
也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。在其他一些分析中，会额外区分一种状态

* RUNNING，但是从 Java API 的角度，并不能表示出来。

* 阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待
Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当
前线程就会处于阻塞状态。

* 等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发
现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类
似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。

* 计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法

* 终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这
个状态叫作死亡。
```


## 什么情况下 Java 程序会产生死锁？如何定位、修复

```txt
两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。

定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，
进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至
可以在图形界面进行有限的死锁检测。

理解线程相关的基本概念，比如各种线程状态和同步、锁、Latch 等并发工具，就已经足够
解决大多数问题了。

嵌套的 synchronized 或者 lock 非常容易出问题
```

## Java 并发包提供了哪些并发工具类

```txt

```
